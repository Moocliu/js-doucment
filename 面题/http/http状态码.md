# 聊一聊 HTTP 的状态码有哪些？

-2XX 成功

200 OK，表示从客户端发来的请求在服务器端被正确处理 ✨
201 Created 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立
202 Accepted 请求已接受，但是还没执行，不保证完成请求
204 No content，表示请求成功，但响应报文不含实体的主体部分
206 Partial Content，进行范围请求 ✨

-3XX 重定向

301 moved permanently，永久性重定向，表示资源已被分配了新的 URL
302 found，临时性重定向，表示资源临时被分配了新的 URL ✨
303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源
304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况
307 temporary redirect，临时重定向，和 302 含义相同

-4XX 客户端错误

400 bad request，请求报文存在语法错误 ✨
401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 ✨
403 forbidden，表示对请求资源的访问被服务器拒绝 ✨
404 not found，表示在服务器上没有找到请求的资源 ✨
408 Request timeout, 客户端请求超时
409 Confict, 请求的资源可能引起冲突

5-XX 服务器错误

500 internal sever error，表示服务器端在执行请求时发生了错误 ✨
501 Not Implemented 请求超出服务器能力范围，例如服务器不支持当前请求所需要的某个功能，或者请求是服务器不支持的某个方法
503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求
505 http version not supported 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本

## 同样是重定向 307，303，302 的区别？

302 是 http1.0 的协议状态码，在 http1.1 版本的时候为了细化 302 状态码又出来了两个 303 和 307。
303 明确表示客户端应当采用 get 方法获取资源，他会把 POST 请求变为 GET 请求进行重定向。
307 会遵照浏览器标准，不会从 post 变为 get。

## HTTP 的 keep-alive 是干什么的？

在早期的 HTTP/1.0 中，每次 http 请求都要创建一个连接，而创建连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在后来的 HTTP/1.0 中以及 HTTP/1.1 中，引入了重用连接的机制，就是在 http 请求头中加入 Connection: keep-alive 来告诉对方这个请求响应完成后不要关闭，下一次咱们还用这个请求继续交流。协议规定 HTTP/1.0 如果想要保持长连接，需要在请求头中加上 Connection: keep-alive。

## keep-alive 的优点：

较少的 CPU 和内存的使用（由于同时打开的连接的减少了）
允许请求和应答的 HTTP 管线化
降低拥塞控制 （TCP 连接减少了）
减少了后续请求的延迟（无需再进行握手）
报告错误无需关闭 TCP 连

## 为什么有了 HTTP 为什么还要 HTTPS？

https 是安全版的 http，因为 http 协议的数据都是明文进行传输的，所以对于一些敏感信息的传输就很不安全，HTTPS 就是为了解决 HTTP 的不安全而生的。
HTTPS 是如何保证安全的？
过程比较复杂，我们得先理解两个概念
对称加密：即通信的双方都使用同一个秘钥进行加解密，比如特务接头的暗号，就属于对称加密
对称加密虽然很简单性能也好，但是无法解决首次把秘钥发给对方的问题，很容易被 hacker 拦截秘钥。
非对称加密：

私钥 + 公钥= 密钥对
即用私钥加密的数据,只有对应的公钥才能解密,用公钥加密的数据,只有对应的私钥才能解密
因为通信双方的手里都有一套自己的密钥对,通信之前双方会先把自己的公钥都先发给对方
然后对方再拿着这个公钥来加密数据响应给对方,等到到了对方那里,对方再用自己的私钥进行解密

非对称加密虽然安全性更高，但是带来的问题就是速度很慢，影响性能。
解决方案：
那么结合两种加密方式，将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。
此时又带来一个问题，中间人问题：
如果此时在客户端和服务器之间存在一个中间人,这个中间人只需要把原本双方通信互发的公钥,换成自己的公钥,这样中间人就可以轻松解密通信双方所发送的所有数据。
所以这个时候需要一个安全的第三方颁发证书（CA），证明身份的身份，防止被中间人攻击。
证书中包括：签发者、证书用途、使用者公钥、使用者私钥、使用者的 HASH 算法、证书到期时间等

但是问题来了，如果中间人篡改了证书，那么身份证明是不是就无效了？这个证明就白买了，这个时候需要一个新的技术，数字签名。
数字签名就是用 CA 自带的 HASH 算法对证书的内容进行 HASH 得到一个摘要，再用 CA 的私钥加密，最终组成数字签名。
当别人把他的证书发过来的时候,我再用同样的 Hash 算法,再次生成消息摘要，然后用 CA 的公钥对数字签名解密,得到 CA 创建的消息摘要,两者一比,就知道中间有没有被人篡改了。
这个时候就能最大程度保证通信的安全了。

作者：寻找海蓝 96
链接：https://juejin.im/post/5d032b77e51d45777a126183
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。







#### 200 和304 的区别？

