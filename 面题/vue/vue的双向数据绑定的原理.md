# 说说 Vue 的双向数据绑定的原理

https://mp.weixin.qq.com/s/jLcz0vZrc-t2D_9vOOB6FA

## 数据劫持/  依赖收集 发布订阅





```
vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.defineProperty()来劫持各个属性的 setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。

具体步骤：

第一步：需要 observe 的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter 和 getter
这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化

第二步：compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

第三步：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要做的事情是:

1、在自身实例化时往属性订阅器(dep)里面添加自己

2、自身必须有一个 update()方法

3、待属性变动 dep.notice()通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调，则功成身退。

第四步：MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据 model 变更的双向绑定效果。


```



##### 既然Vue通过数据劫持可以精准探测数据变化,为什么还需要虚拟DOM进行diff检测差异?

```
当Vue程序初始化后 就会对数据data 进行依赖收集，一但数据发生变化，响应式系统就立刻得知 ，因此vue是一开始就知道[在哪发生了变化]，但是又产生一个问题，熟悉vue的响应式就知道，通常一个绑定一个数据就需要一个watcher,一但我们的绑定细粒度过高就会产生大量的watcher ，这样就会带来 内存以及依赖追踪的很大开销，而细粒度过低会无法精确侦测数据变化，因此Vue设计选择中度细粒度方案 ，在组件级别进行数据帧测，通常我们会第一时间侦测到发生变化的组件，然后在组件内部进行diff进新旧虚拟dom的对比 
```





##### diff的原理

```
diff过程可以概括： oldvnode 和newvnode 各有两个头尾的变量startdx 和Endldx ，它们的2个变量相互比较
```

